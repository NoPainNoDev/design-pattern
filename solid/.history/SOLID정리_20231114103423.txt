
1. 단일 책임 원칙 (Simple Responsibility Principle)

- 모든 클래스는 하나의 책임만 가져야 한다. 
- 클래스는 책임에 대해서 완전히 캡슐화 해야 한다.

ex) 계산기(클래스)
    사칙연산(책임)
    계산기는 사칙연산(만)을 책임진다.
    클래스를 수정하는 것은 사칙연산 책임에 대한 대응이지, 
    두가지 이상의 이유가 있으면 안된다.


2.  개방 폐쇄 원칙 (Open Closed Principle)

- 확장에는 열려있고, 수정에는 닫혀있다.
- 클래스는 기능을 추가할 수 있다. (Open) 
- 기존의 코드를 변경하지 않는다. (Close)

ex) 캐릭터(상위클래스)
    새로운 캐릭터 A(하위클래스)
    A의 움직임이 다를 경우
    캐릭터 코드를 수정할 필요 없이, (Close)
    A 캐릭터의 움직임을 재정의 한다. (Open)


3. 리스코프 치환 원칙 (Liskov Substitution Principle)

- 자식 클래스는 언제나 부모 클래스를 대체할 수 있다.
- 부모 클래스 자리에 자식 클래스가 와도 잘 작동해야 한다.
- 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의 하지 않는다.
- 자식 클래스는 확장만 수행하도록 한다.

* 확장 : 기존 기능을 상속 + 추가적인 기능 구현
* 재정의 : 상속받은 기능을 다시 작성하는 것

ex) 동물(부모) - 새(자식)
    새에 "날다" 함수를 추가 = 확장
    동물에 "울음" 함수를 새에서 다시 재작성 = 재정의


4. 인터페이스 분리 원칙 (Interface Segregation Principle)

- 사용하지 않는 인터페이스는 클래스로 구현하지 말아야 한다.
- 하나의 일반적인 인터페이스보다 여러개의 구체적인 인터페이스가 낫다.

ex) 복합기(클래스) 
    인쇄(메서드), 스캔(메서드)
    인쇄 기능만 필요한 경우
    스캔 기능만 필요한 경우 
    필요없는 기능 또한 상속 받을 수 있게 되므로,
    인쇄와 스캔에 대해 인터페이스를 따로 만들어줘야 한다.


5. 의존 역전 원칙 (Dependency Inversion Principle)

- 의존을 맺을 때에는 변화가 거의 없거나 변화가 어려운 것과 맺어야 한다.
- 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺어야 한다.

ex) 고수준 모듈(비즈니스 로직 클래스)
    저수준 모듈(데이터베이스 통신 클래스)
    고수준 모듈은 저수준 모듈에 직접 의존해서는 안된다.
    둘 다 추상화에 의존해야 한다.
    => 데이터베이스 통신 클래스에 대한 추상화를 진행 (인터페이스화)
    => 비즈니스 로직 클래스는 해당 인터페이스를 의존